/****************************************************************
 * MAIN.CPP
 * 
 * This file contains the functions starting the Virtual Belgium
 * simulation.
 * 
 * Authors: J. Barthelemy and L. Hollaert
 * Date   : 17 july 2012
 ****************************************************************/

/*! \file main.cpp
 *  \brief Main method and functions handling the launching of the simulation.
 */

/*!\mainpage VirtualBelgium Documentation
 *
 * \section intro_sec Introduction
 *
 * This is the VirtualBelgium documentation.
 * 
 * The VirtualBelgium project aims at developing understanding of 
 * the evolution of the Belgian population using simulation and 
 * considers various aspects of this evolution (demographics, 
 * residential choice, activity patterns, mobility, ...).
 * It is based on a validated synthetic population for the 
 * country and is intrinsically multi-disciplinary.
 *
 * The project is organized as follow:
 * - ./ : running scripts for launching VirtualBelgium;
 * - ./bin : VirtualBelgium executable and configuration files;
 * - ./data : contains the necessary inputs;
 * - ./doc : documentation (generated by doxygen);
 * - ./include : headers files;
 * - ./licenses : licenses of Repast HPC, tinyxml2 and VirtualBelgium;
 * - ./logs : log files of simulation runs;
 * - ./outputs : outputs generated by simulation runs;
 * - ./scripts : scripts for processing outputs;
 * - ./tools : tools for processing outputs
 * - ./src : source files.
 *
 *
 * \section install_sec Installation
 *
 * \subsection tools_subsec Requirements
 * Minimal requirements for VirtualBelgium are
 *
 * - Repast HPC 1.0.1;
 * - Boost library 1.49;
 * - a working MPI environment (openmpi or mpich2);
 * - gcc 4.7.2.
 *
 * VirtualBelgium provides scripts to process its outputs. These
 * scripts requires:
 * - Python and mapnik 2 library;
 * - R;
 * - doxygen;
 * - Perl.
 *
 *
 * \subsection install_subsec Installation
 * Depending on the hardware configuration execute
 * - make all (on a regular workstation)
 * - make ucl (on lemaitre2 cluster running the SLURM job management system)
 *
 *
 * \section running Running the simulation
 * After setting the model properties (./bin/model.props), you can launch
 * the run.sh NP script, where NP is the desired number of process used
 * by VirtualBelgium.
 *
 * If a segmentation fault occurs, you maybe need to increase the stack size with the command
 *
 * ulimit -s 100000
 *
 * The outputs will be stored in the output directory and can be processed
 * with the tools of the scripts directory:
 * - merge_xml.sh : merge the outputs generated by the NP process into one single file;
 * - merge_shp.R : merge a shapefile with the data generated by the simulation;
 * - mpas_generation.py : generate 24 maps, each one representing the number of activities starting at a given hour.
 *
 *
 * \section debug Debugging
 * In order to debug, follows these steps:
 *
 * 1. compiling: make debug
 * 2. go the /bin directory
 * 3. execute : mpiexec -n NP xterm -e gdb ./vbel
 *
 * where NP is the desired number of processes.
 *
 * \section Documentation generation
 *
 * Move to the /doc directory and execute: doxygen vbel
 *
 * <BR><BR>
 */

#include "repast_hpc/RepastProcess.h"
#include "repast_hpc/io.h"
#include "repast_hpc/logger.h"
#include "repast_hpc/Utilities.h"
#include "repast_hpc/initialize_random.h"
#include <boost/mpi.hpp>
#include <boost/serialization/export.hpp>
#include <boost/lexical_cast.hpp>
#include <vector>
#include <exception>
#include <time.h>
#include <iomanip>
#include "../include/Model.hpp"
#include "../include/Data.hpp"
#include "../include/Random.hpp"
#include "../include/Network.hpp"


using namespace std;
using namespace repast;
using namespace boost;

/*!
 * Print to the standard error output the required arguments to
 * execute Virtual Belgium.
 */
void usage() {
  std::cerr << "usage: vbel  string string" << endl;
  std::cerr << "  first string: string is the path to the Repast HPC \n\tconfiguration properties file" << endl;
  std::cerr << "  second string: string is the path to the model properties file" << endl;
}

//! Initialize and launch the simulation.
/*!
 * \param propsFile the file containing VirtualBelgium properties.
 * \param argc the total number of arguments passed to the main function.
 * \param argv the arguments passed to the main function.
 */
void runSimulation(std::string propsFile, int argc, char ** argv) {

  // Initialization of mpi's world.
  mpi::communicator world;

  // Random draws generator initialization.
  RandomGenerators::makeInstance((unsigned long long)world.rank());

  // Reading model's properties
  Properties props(propsFile, argc, argv, &world);

  // Timer.
  Timer timer;
  string time;
  timestamp(time);
  props.putProperty("date_time.run", time);
  props.putProperty("process.count", world.size());
  timer.start();

  // Create and initialize the inputs and the model.
  Data::makeInstance(props);
  props.putProperty("data_creation.time", timer.stop());
  props.putProperty("number.nodes",Data::getInstance()->getNetwork().getNodes().size());
  props.putProperty("number.links",Data::getInstance()->getNetwork().getLinks().size());

  Model model(&world, props);
  props.putProperty("model_init.time", timer.stop());
  model.initSchedule();

  // Get the schedule runner and run it, starting the simulation.
  if (world.rank() == 0) cout << "Starting simulation... " << endl;
  ScheduleRunner & runner = RepastProcess::instance()->getScheduleRunner();
  runner.run();
  props.putProperty("run.time", timer.stop());

  // Writing the log file (only for the root process).
  if (world.rank() == 0) {
    vector<string> keysToWrite;
    keysToWrite.push_back("date_time.run");              // starting time of the simulation
    keysToWrite.push_back("process.count");              // number of process
    keysToWrite.push_back("data_creation.time");         // time required to read the data
    keysToWrite.push_back("model_init.time");            // time required to initialize the agents
    keysToWrite.push_back("run.time");                   // run time of the simulation
    keysToWrite.push_back("number.individuals");
    keysToWrite.push_back("number.nodes");
    keysToWrite.push_back("number.links");
    props.log("root");
    props.writeToSVFile("../logs/log_simulation.csv", keysToWrite);
  }

  // Free the memory
  Data::getInstance()->kill();
  RandomGenerators::getInstance()->kill();

}


//! Main function.
/*!
 * \return EXIT_SUCCESS if the simulation's launching is successful, EXIT_FAILURE otherwise.
 */
int main(int argc, char ** argv) {

  // MPI and simulation variable
  mpi::environment env(argc, argv);   // MPI environment
  mpi::communicator world;            // MPI communicator
  string config, props;               // configuration and properties files

  // Setting the output precision
  cout << setprecision(15);

  // Reading the repast configuration and model properties file paths.
  if (argc >= 3) {
    config = argv[1];
    props = argv[2];
  } else {
    if (world.rank() == 0)
      usage();
    return 0;
  }

  // Starting the simulation
  if (config.size() > 0 && props.size() > 0) {
    RepastProcess::init(config, &world);
    runSimulation(props, argc, argv);
  } else {
    if (world.rank() == 0)
      usage();
    return EXIT_FAILURE;
  }

  // Ending the simulation
  if( world.rank() == 0 ) {
    cout << "End of simulation!\n";
  }

  // Freeing memory
  RepastProcess::instance()->done();

  return EXIT_SUCCESS;

}
